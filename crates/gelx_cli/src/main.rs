use std::fs;

use clap::Parser;
use gelx_core::GelxCoreError;
use gelx_core::GelxCoreResult;
use gelx_core::GelxMetadata;
use gelx_core::generate_enums;
use gelx_core::generate_query_token_stream;
use gelx_core::get_descriptor;
use gelx_core::prettify;

/// A CLI for generating typed Rust code from Gel queries
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Cli {
	#[clap(subcommand)]
	command: Commands,
}

#[derive(Parser, Debug)]
enum Commands {
	/// Generates Rust code from the crate in the current directory.
	Generate,
	/// Checks if the generated Rust code is up-to-date
	Check,
}

#[tokio::main]
async fn main() -> GelxCoreResult<()> {
	let cli = Cli::parse();

	// Load metadata from Cargo.toml or gelx.toml in the current directory
	let current_dir = std::env::current_dir()?;
	let metadata = GelxMetadata::try_new(current_dir)?;

	match cli.command {
		Commands::Generate => handle_generate(&metadata).await,
		Commands::Check => handle_check(&metadata).await,
	}
}

async fn handle_generate(metadata: &GelxMetadata) -> GelxCoreResult<()> {
	eprintln!("Generating code...");
	let generated_code = generate_all_queries_code(metadata).await?;

	if let Some(parent) = metadata.output.parent() {
		fs::create_dir_all(parent)?;
	}

	fs::write(&metadata.output, &generated_code)?;
	eprintln!(
		"Successfully wrote generated code to {}",
		metadata.output.display()
	);

	Ok(())
}

async fn handle_check(metadata: &GelxMetadata) -> GelxCoreResult<()> {
	eprintln!("Checking code...");
	let generated_code = generate_all_queries_code(metadata).await?;

	if !metadata.output.exists() {
		eprintln!(
			"Error: Output file {} does not exist. Run `gelx generate` first.",
			metadata.output.display()
		);
		std::process::exit(1);
	}

	let existing_code = fs::read_to_string(&metadata.output)?;

	if generated_code != existing_code {
		eprintln!("Error: Generated code is not up-to-date. Please run `gelx generate`.");
		// Optional: print diff here if desired
		// For simplicity, we're not adding a full diff implementation now.
		// A simple way could be to write both to temp files and use `diff` command.
		std::process::exit(1);
	}

	eprintln!("Generated code is up-to-date.");
	Ok(())
}

async fn generate_all_queries_code(metadata: &GelxMetadata) -> GelxCoreResult<String> {
	if !metadata.queries.is_dir() {
		return Err(GelxCoreError::Custom(format!(
			"Queries directory not found: {}",
			metadata.queries.display()
		)));
	}

	let mut all_generated_code = String::new();

	all_generated_code.push_str("// This file is @generated by gelx.\n");
	all_generated_code.push_str("// It is not intended for manual editing.\n");
	all_generated_code.push_str("// To update it, run `gelx generate`.\n");
	all_generated_code.push_str("#![cfg_attr(rustfmt, rustfmt_skip)]\n");
	all_generated_code.push_str("#![allow(unused)]\n");

	let enum_code = generate_enums(metadata, false).await?;
	all_generated_code.push_str(&enum_code.to_string());

	for entry in fs::read_dir(&metadata.queries)? {
		let entry = entry?;
		let path = entry.path();

		if path.is_file() && path.extension().is_some_and(|ext| ext == "edgeql") {
			let query_content = fs::read_to_string(&path)?;
			let file_stem = path.file_stem().unwrap_or_default().to_string_lossy();
			// Use metadata for naming conventions if available, otherwise defaults.
			let module_name = file_stem.to_string();

			eprintln!("Processing query: {}", path.display());
			let descriptor = get_descriptor(&query_content, metadata).await?;
			let token_stream = generate_query_token_stream(
				&descriptor,
				&module_name,
				&query_content,
				metadata,
				false,
			)?;

			all_generated_code.push_str(&token_stream.to_string());
			all_generated_code.push('\n');
		}
	}

	if all_generated_code.lines().count() <= 2 {
		// Only comments
		eprintln!(
			"Warning: No .edgeql files found in {}. Generated file will be empty.",
			metadata.queries.display()
		);
	}

	Ok(prettify(&all_generated_code)?)
}
