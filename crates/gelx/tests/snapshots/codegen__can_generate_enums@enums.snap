---
source: crates/gelx/tests/codegen.rs
expression: value
---
mod.rs
//! This file is generated by `gelx generate`.
//! It is not intended for manual editing.
//! To update it, run `gelx generate`.
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(unused_qualifications)]
#![allow(clippy::all)]
use ::gelx::exports as __g;
pub use default::*;
#[path = "additional.rs"]
pub mod additional;
#[path = "default.rs"]
pub mod default;
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::typed_builder::TypedBuilder,
    __g::gel_derive::Queryable
)]
#[builder(crate_module_path = __g::typed_builder)]
#[gel(crate_path = __g::gel_protocol)]
#[builder(field_defaults(default, setter(into, strip_option(fallback_suffix = "_opt"))))]
pub struct Globals {
    pub alternative: Option<String>,
    pub current_user_id: Option<__g::uuid::Uuid>,
}
impl __g::gel_tokio::GlobalsDelta for Globals {
    fn apply(self, modifier: &mut __g::gel_tokio::state::GlobalsModifier<'_>) {
        modifier.set("additional::alternative", self.alternative);
        modifier.set("default::current_user_id", self.current_user_id);
    }
}
impl Globals {
    /// Create a gel client with the globals.
    pub async fn into_client(
        self,
    ) -> ::core::result::Result<__g::gel_tokio::Client, __g::gel_tokio::Error> {
        let client = __g::gel_tokio::create_client().await?.with_globals(self);
        Ok(client)
    }
    /// Create a gel client with the globals.
    pub async fn to_client(
        &self,
    ) -> ::core::result::Result<__g::gel_tokio::Client, __g::gel_tokio::Error> {
        let client = self.clone().into_client().await?;
        Ok(client)
    }
}


additional.rs
//! This file is generated by `gelx generate`.
//! It is not intended for manual editing.
//! To update it, run `gelx generate`.
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(unused_qualifications)]
#![allow(clippy::all)]
use super::*;
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    ::core::marker::Copy,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::gel_derive::Queryable,
    __g::strum::AsRefStr,
    __g::strum::Display,
    __g::strum::EnumString,
    __g::strum::EnumIs,
    __g::strum::FromRepr,
    __g::strum::IntoStaticStr
)]
#[gel(crate_path = __g::gel_protocol)]
#[strum(crate = "__g::strum")]
pub enum Awesomeness {
    Very,
    Somewhat,
    NotReally,
}
impl ::core::convert::From<Awesomeness> for __g::gel_protocol::value::Value {
    fn from(value: Awesomeness) -> Self {
        __g::gel_protocol::value::Value::Enum(value.as_ref().into())
    }
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    ::core::marker::Copy,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::gel_derive::Queryable,
    __g::strum::AsRefStr,
    __g::strum::Display,
    __g::strum::EnumString,
    __g::strum::EnumIs,
    __g::strum::FromRepr,
    __g::strum::IntoStaticStr
)]
#[gel(crate_path = __g::gel_protocol)]
#[strum(crate = "__g::strum")]
pub enum Smartness {
    #[serde(rename = "low")]
    #[gel(rename = "low")]
    #[strum(serialize = "low")]
    Low,
    #[serde(rename = "mid")]
    #[gel(rename = "mid")]
    #[strum(serialize = "mid")]
    Mid,
    #[serde(rename = "genius")]
    #[gel(rename = "genius")]
    #[strum(serialize = "genius")]
    Genius,
}
impl ::core::convert::From<Smartness> for __g::gel_protocol::value::Value {
    fn from(value: Smartness) -> Self {
        __g::gel_protocol::value::Value::Enum(value.as_ref().into())
    }
}


default.rs
//! This file is generated by `gelx generate`.
//! It is not intended for manual editing.
//! To update it, run `gelx generate`.
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(unused_qualifications)]
#![allow(clippy::all)]
use super::*;
mod account {
    use super::*;
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    ::core::marker::Copy,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::gel_derive::Queryable,
    __g::strum::AsRefStr,
    __g::strum::Display,
    __g::strum::EnumString,
    __g::strum::EnumIs,
    __g::strum::FromRepr,
    __g::strum::IntoStaticStr
)]
#[gel(crate_path = __g::gel_protocol)]
#[strum(crate = "__g::strum")]
pub enum AccountProvider {
    Github,
}
impl ::core::convert::From<AccountProvider> for __g::gel_protocol::value::Value {
    fn from(value: AccountProvider) -> Self {
        __g::gel_protocol::value::Value::Enum(value.as_ref().into())
    }
}
mod email {
    use super::*;
}
mod location {
    use super::*;
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    __g::serde::Serialize,
    __g::serde::Deserialize
)]
pub struct Position(pub i32);
impl __g::gel_protocol::queryable::Queryable for Position {
    type Args = <i32 as __g::gel_protocol::queryable::Queryable>::Args;
    fn decode(
        decoder: &__g::gel_protocol::queryable::Decoder,
        args: &Self::Args,
        buf: &[u8],
    ) -> Result<Self, __g::gel_protocol::errors::DecodeError> {
        Ok(Self(i32::decode(decoder, args, buf)?))
    }
    fn check_descriptor(
        ctx: &__g::gel_protocol::queryable::DescriptorContext,
        type_pos: __g::gel_protocol::descriptors::TypePos,
    ) -> Result<Self::Args, __g::gel_protocol::queryable::DescriptorMismatch> {
        __g::check_scalar(
            ctx,
            type_pos,
            Default::default(),
            "default::Position",
        )?;
        Ok(())
    }
}
impl ::core::convert::From<Position> for __g::gel_protocol::value::Value {
    fn from(value: Position) -> Self {
        value.0.into()
    }
}
impl ::core::convert::From<Position> for i32 {
    fn from(value: Position) -> Self {
        value.0
    }
}
impl ::core::convert::From<i32> for Position {
    fn from(value: i32) -> Self {
        Position(value)
    }
}
impl ::std::ops::Deref for Position {
    type Target = i32;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for Position {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
mod project {
    use super::*;
}
mod relationship {
    use super::*;
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    ::core::marker::Copy,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::gel_derive::Queryable,
    __g::strum::AsRefStr,
    __g::strum::Display,
    __g::strum::EnumString,
    __g::strum::EnumIs,
    __g::strum::FromRepr,
    __g::strum::IntoStaticStr
)]
#[gel(crate_path = __g::gel_protocol)]
#[strum(crate = "__g::strum")]
pub enum RelationshipType {
    Follow,
    Block,
    Mute,
}
impl ::core::convert::From<RelationshipType> for __g::gel_protocol::value::Value {
    fn from(value: RelationshipType) -> Self {
        __g::gel_protocol::value::Value::Enum(value.as_ref().into())
    }
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    ::core::marker::Copy,
    __g::serde::Serialize,
    __g::serde::Deserialize,
    __g::gel_derive::Queryable,
    __g::strum::AsRefStr,
    __g::strum::Display,
    __g::strum::EnumString,
    __g::strum::EnumIs,
    __g::strum::FromRepr,
    __g::strum::IntoStaticStr
)]
#[gel(crate_path = __g::gel_protocol)]
#[strum(crate = "__g::strum")]
pub enum Role {
    None,
    Editor,
    Moderator,
    Admin,
    Owner,
}
impl ::core::convert::From<Role> for __g::gel_protocol::value::Value {
    fn from(value: Role) -> Self {
        __g::gel_protocol::value::Value::Enum(value.as_ref().into())
    }
}
mod simple {
    use super::*;
}
mod team {
    use super::*;
}
mod user {
    use super::*;
}
#[derive(
    ::std::fmt::Debug,
    ::core::clone::Clone,
    __g::serde::Serialize,
    __g::serde::Deserialize
)]
pub struct UserId(pub i64);
impl __g::gel_protocol::queryable::Queryable for UserId {
    type Args = <i64 as __g::gel_protocol::queryable::Queryable>::Args;
    fn decode(
        decoder: &__g::gel_protocol::queryable::Decoder,
        args: &Self::Args,
        buf: &[u8],
    ) -> Result<Self, __g::gel_protocol::errors::DecodeError> {
        Ok(Self(i64::decode(decoder, args, buf)?))
    }
    fn check_descriptor(
        ctx: &__g::gel_protocol::queryable::DescriptorContext,
        type_pos: __g::gel_protocol::descriptors::TypePos,
    ) -> Result<Self::Args, __g::gel_protocol::queryable::DescriptorMismatch> {
        __g::check_scalar(
            ctx,
            type_pos,
            Default::default(),
            "default::UserId",
        )?;
        Ok(())
    }
}
impl ::core::convert::From<UserId> for __g::gel_protocol::value::Value {
    fn from(value: UserId) -> Self {
        value.0.into()
    }
}
impl ::core::convert::From<UserId> for i64 {
    fn from(value: UserId) -> Self {
        value.0
    }
}
impl ::core::convert::From<i64> for UserId {
    fn from(value: i64) -> Self {
        UserId(value)
    }
}
impl ::std::ops::Deref for UserId {
    type Target = i64;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ::std::ops::DerefMut for UserId {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
mod wallet {
    use super::*;
}
